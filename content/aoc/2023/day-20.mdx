---
title: "How I solved Day 20: Pulse Propaga&shy;tion in Elixir"
subheading: "Advent of Code 2023"
seo_title: "Advent of Code 2023, Day 20: Pulse Propagation"
published: false
published_at: "2024-08-01"
---

Advent of Code 2023's Day 20 problem: [Pulse Propagation][pulse-propagation] is
one of my favourite problems. I took quite some time to solve it, and looking
back, it's a great way to showcase almost all the things I love about Elixir.

Here's my approach of solving this problem, accompanied by how Elixir's
(mental) model helped me. I skip over some things which are "basic" to Elixir,
so you can refer to the [official docs](https://elixir-lang.org) if something
doesn't quite make sense. In a gist:

- Elixir is a dynamic and functional language
- `|>` is the [pipe operator](https://hexdocs.pm/elixir/enumerable-and-streams.html#the-pipe-operator),
  pretty central to the language; passes result of the left operation as the
  first argument for the right operation
- There is no `return` keyword, the value returned by a function is the value
  returned by its last expression
- [Functions. Describe. The World.](https://www.youtube.com/watch?v=PAZTIAfaNr8)

## Table of contents

## Problem statement

You can read the [original statement in full][pulse-propagation], but here's
the important bits (emphasis not mine):

> Modules communicate using **pulses**. Each pulse is either a **high pulse**
> or a **low pulse**. When a module sends a pulse, it sends that type of pulse
> to each module in its list of **destination modules**.
>
> There are several different types of modules:
>
> **Flip-flop modules** (prefix %) are either **on** or **off**; they are
> initially **off**. If a flip-flop module receives a high pulse, it is ignored
> and nothing happens. However, if a flip-flop module receives a low pulse, it
> **flips between on and off**. If it was off, it turns on and sends a high
> pulse. If it was on, it turns off and sends a low pulse.
>
> **Conjunction** modules (prefix &) **remember** the type of the most recent
> pulse received from **each** of their connected input modules; they initially
> default to remembering a **low pulse** for each input. When a pulse is
> received, the conjunction module first updates its memory for that input.
> Then, if it remembers **high pulses** for all inputs, it sends a **low pulse**;
> otherwise, it sends a **high pulse**.
>
> There is a single **broadcast module** (named broadcaster). When it receives
> a pulse, it sends the same pulse to all of its destination modules.
>
> Here at Desert Machine Headquarters, there is a module with a
> **single button** on it called, aptly, the button module. When you push the
> button, a single **low pulse** is sent directly to the broadcaster module.
>
> After pushing the button, you must wait until all pulses have been delivered
> and fully handled before pushing it again. Never push the button if modules
> are still processing pulses.
>
> Pulses are always processed **in the order they are sent**. So, if a pulse is
> sent to modules a, b, and c, and then module a processes its pulse and sends
> more pulses, the pulses sent to modules b and c would have to be handled first.

{/* TODO add more */}

There's a lot of words to make the problem more thematic, but the takeaways are:

- There's one input, `broadcaster` module
- Modules can be of two types, flip-flop modules, denoted by `%`, and
  conjunction modules denoted by `&`.
- Flip-flop modules switch between `on` and `off`, are initially `off`, but flip
  only when they receive a `low` pulse. `high` pulses are ignored.
- Conjunctions modules will store the type of _most recent_ pulse received from
  _each_ of its inputs, initially `low` for each.
- When it receives a pulse, it checks if it "remembers" `high` pulses from _all_
  its inputs, and forwards a `low` pulse if so, `high` otherwise.

With this in mind, we're ready to begin.

## Parsing input

Here's the sample input:

```plain hide-line-numbers filename="input.txt"
broadcaster -> a
%a -> inv, con
&inv -> b
%b -> con
&con -> output
```

We'll need to parse this and create a [`Map`](https://hexdocs.pm/elixir/Map.html)
to store our module connections. Looking at our sample input, here's some pseudocode:

```plain hide-line-numbers
- split input to lines
- iterate through each line
- if starts with `%`, flip-flop
- if starts with `&`, conjunction
- broadcaster, output
```

A couple of handy Elixir-isms will help us out here:

```elixir
# Anonymous functions
[1, 2, 3]
|> Enum.map(fn x -> x + 2 end) # [3, 4, 5]


# Pattern matching, and match (=) and capture (&) operator
# = matches the value on the right to the variable
x = 1
x = 1 # valid
1 = x # valid, both are one
2 = x # ** (MatchError) no match of right hand side value: 1

# &(&1 + 2) is the same as x -> x + 2
[first | rest] = Enum.map([1, 2, 3], &(&1 + 2))
IO.inspect({first, rest}) # {3, [4, 5]}

# Atoms are constants whose value is its own name,
# tuples use curly braces; together they're great
# for enumerating over specific, known values
# Commonly used like:
{:ok, val}
{:err, error}


# Compare a variable until we find a match
case string do # when string is "prefix_test"
  "prefix_" <> rest = whole ->
    IO.inspect({whole, rest}) # {"prefix_test", "test"}

  _ -> nil # base case, _ matches all remaining cases
end
```

<ParseInput />

And processing the given input thus far gives us:

```elixir
[
  # module_type, output modules, flip-flop/input modules state
  {"broadcast", ["a"]},
  {"a", {:flip, ["inv", "con"], :off}},
  {"inv", {:conj, ["b"], %{}}},
  {"b", {:flip, ["con"], :off}},
  {"con", {:conj, ["output"], %{}}}
]
```

...but there's a problem: we don't have the inputs mapped for the `conj` modules.
We'll need to iterate over the modules and create a map of `conj` modules and
their inputs, and then merge them.

<ParseInput conjunctionInputsStage />

All together now:

```elixir
defp parse_input(input) do
  input
  |> String.split("\n")
  |> Enum.map(fn
    "broadcaster -> " <> starter_mods ->
      starter_mods
      |> String.split(", ")
      |> then(&{"broadcast", &1})

    "%" <> str ->
      [mod, dest_raw] = String.split(str, " -> ")

      dest = String.split(dest_raw, ", ", trim: true)

      {mod, {:flip, dest, :off}}

    "&" <> str ->
      [mod, dest_raw] = String.split(str, " -> ")

      dest = String.split(dest_raw, ", ", trim: true)

      {mod, {:conj, dest, %{}}}
  end)
  |> then(fn init_entries ->
    conjs =
      init_entries
      |> Enum.flat_map(fn
        {node, {:conj, _, _}} -> [node]
        _ -> []
      end)

    conjunction_modules_input_map =
      init_entries
      |> Enum.reduce(%{}, fn
        {node, {_, dest_mods, _}}, conjs_map ->
          dest_mods
          |> Enum.filter(&Enum.member?(conjs, &1))
          |> case do
            [] ->
              conjs_map

            matches ->
              matches
              |> Enum.reduce(conjs_map, fn
                dest_mod, map ->
                  map
                  |> Map.update(
                    dest_mod,
                    %{node => :low},
                    fn input_mods ->
                      input_mods
                      |> Map.put(node, :low)
                  end)
              end)
          end

        _, conjs_map ->
          conjs_map
      end)

    {init_entries, conjunction_modules_input_map}
  end)
  |> then(fn {entries, conjs_map} ->
    entries
    |> Map.new()
    |> Map.merge(conjs_map, fn
      _, {:conj, dest, _}, inputs_map ->
        {:conj, dest, inputs_map}
    end)
  end)
end
```

Parsing our example input now gives us an accurate map:

```elixir
%{
  "a" => {:flip, ["inv", "con"], :off},
  "b" => {:flip, ["con"], :off},
  "broadcast" => ["a"],
  "con" => {:conj, ["output"], %{"a" => :low, "b" => :low}},
  "inv" => {:conj, ["b"], %{"a" => :low}}
}
```

## Result

```elixir filename="day_20.ex"
defmodule PulsePropagation do
  defp parse_input(input) do
    input
    |> String.split("\n")
    |> Enum.map(fn
      "broadcaster -> " <> starter_mods ->
        starter_mods
        |> String.split(", ")
        |> then(&{"broadcast", &1})

      "%" <> str ->
        # flip-flop
        [mod, dest_raw] = String.split(str, " -> ")

        dest = String.split(dest_raw, ", ", trim: true)

        {mod, {:flip, dest, :off}}

      "&" <> str ->
        # conjunction
        [mod, dest_raw] = String.split(str, " -> ")

        dest = String.split(dest_raw, ", ", trim: true)

        {mod, {:conj, dest, %{}}}
    end)
    |> then(fn init_entries ->
      conjs =
        init_entries
        |> Enum.flat_map(fn
          {node, {:conj, _, _}} -> [node]
          _ -> []
        end)

      conjunction_modules_input_map =
        init_entries
        |> Enum.reduce(%{}, fn
          {node, {_, dest_mods, _}}, conjs_map ->
            dest_mods
            |> Enum.filter(&Enum.member?(conjs, &1))
            |> case do
              [] ->
                conjs_map

              matches ->
                matches
                |> Enum.reduce(
                  conjs_map,
                  fn dest_mod, map ->
                    map
                    |> Map.update(
                      dest_mod,
                      %{node => :low},
                      fn input_mods ->
                        input_mods
                        |> Map.put(node, :low)
                      end
                    )
                  end
                )
            end

          _, conjs_map ->
            conjs_map
        end)

      {init_entries, conjunction_modules_input_map}
    end)
    |> then(fn {entries, conjs_map} ->
      entries
      |> Map.new()
      |> Map.merge(
        conjs_map,
        fn _, {:conj, dest, _}, inputs_map ->
          {:conj, dest, inputs_map}
        end
      )
    end)
  end

  defp check_if_all_inputs_high?(map) do
    map
    |> Map.values()
    |> Enum.all?(&(&1 == :high))
  end

  defp check_if_all_flip_flops_are_off?(map) do
    map
    |> Map.values()
    |> Enum.reduce_while(true, fn
      {:flip, _, :on}, _ ->
        {:halt, false}

      {:flip, _, :off}, _ ->
        {:cont, true}

      _, check ->
        {:cont, check}
    end)
  end

  defp process_module({node, signal, sender}, node_map) do
    node_map
    |> Map.get_and_update(node, fn node_details ->
      case node_details do
        {:flip, dest_mods, :off} when signal == :low ->
          dest_mods
          |> Enum.map(&{&1, :high, node})
          |> then(&{&1, {:flip, dest_mods, :on}})

        {:flip, dest_mods, :on} when signal == :low ->
          dest_mods
          |> Enum.map(&{&1, :low, node})
          |> then(&{&1, {:flip, dest_mods, :off}})

        {:conj, dest_mods, inputs} ->
          inputs
          |> Map.put(sender, signal)
          |> then(fn updated_inputs ->
            cond do
              check_if_all_inputs_high?(updated_inputs) ->
                dest_mods
                |> Enum.map(&{&1, :low, node})

              true ->
                dest_mods
                |> Enum.map(&{&1, :high, node})
            end
            |> then(
              &{&1, {:conj, dest_mods, updated_inputs}}
            )
          end)

        {:output, _} = x ->
          {[], x}

        nil ->
          {[], {:output, []}}

        x ->
          {[], x}
      end
    end)
  end

  defp get_dependents(map, mod, one_level_deep \\ false) do
    map
    |> Map.to_list()
    |> Enum.flat_map(fn
      {src, {:conj, dest_mods, _}} ->
        dest_mods
        |> Enum.member?(mod)
        |> case do
          true when one_level_deep == false ->
            get_dependents(map, src, true)

          true ->
            [src]

          false ->
            []
        end

      {src, {:flip, dest_mods, _status}} ->
        dest_mods
        |> Enum.member?(mod)
        |> case do
          true ->
            [src]

          false ->
            []
        end

      _ ->
        []
    end)
  end

  defp is_high_signal_to_dependents(
         {_node, signal, sender},
         dependents
       ) do
    cond do
      Enum.member?(dependents, sender) and signal == :high ->
        true

      true ->
        false
    end
  end

  defp process_signal(
         pulses,
         node_map,
         dependents \\ [],
         counts \\ {1, 0}
       )

  defp process_signal([], node_map, _, counts),
    do: {{node_map, counts}, false}

  defp process_signal(
         [pulse | rest_pulses],
         node_map,
         dependents,
         {low_count, high_count}
       ) do
    pulse_counts =
      case pulse do
        {_, :high, _} -> {low_count, high_count + 1}
        {_, :low, _} -> {low_count + 1, high_count}
      end

    process_module(pulse, node_map)
    |> then(fn {next_modules, updated_map} ->
      rest_pulses
      |> add_lists(next_modules)
      |> process_signal(
        updated_map,
        dependents,
        pulse_counts
      )
      |> then(fn {result, dependent_high} ->
        {result,
         dependent_high ||
           is_high_signal_to_dependents(pulse, dependents)}
      end)
    end)
  end

  defp add_lists(enumerator, list) do
    [enumerator | list]
    |> List.flatten()
  end

  def gcd(a, 0), do: a
  def gcd(0, b), do: b
  def gcd(a, b), do: gcd(b, rem(a, b))

  def lcm(0, 0), do: 0
  def lcm(a, b), do: div(a * b, gcd(a, b))

  def part_1(input) do
    {broadcast, parsed} =
      input
      |> parse_input()
      |> then(fn map ->
        broadcast = Map.get(map, "broadcast")

        {broadcast, map}
      end)

    broadcast
    |> Enum.map(&{&1, :low, "broadcast"})
    |> then(fn init_pulses ->
      1..1000
      |> Enum.reduce(
        {parsed, {0, 0}, 0},
        fn _,
           {map, {low_counts, high_counts}, all_off_count} ->
          init_pulses
          |> process_signal(map)
          |> then(fn {{updated_map,
                       {updated_low_counts,
                        updated_high_counts}}, _} ->
            cond do
              check_if_all_flip_flops_are_off?(updated_map) ->
                {updated_map,
                 {low_counts + updated_low_counts,
                  high_counts + updated_high_counts},
                 all_off_count + 1}

              true ->
                {updated_map,
                 {low_counts + updated_low_counts,
                  high_counts + updated_high_counts},
                 all_off_count}
            end
          end)
        end
      )
      |> then(fn {_, {lows, highs}, _} -> lows * highs end)
    end)
    |> IO.inspect(label: "part_1")
  end

  def part_2(input) do
    {broadcast, parsed} =
      input
      |> parse_input()
      |> then(fn map ->
        broadcast = Map.get(map, "broadcast")

        {broadcast, map}
      end)

    dependents = get_dependents(parsed, "rx")

    broadcast
    |> Enum.map(&{&1, :low, "broadcast"})
    |> then(fn init_pulses ->
      {parsed, [], 0, false}
      |> Stream.unfold(fn
        {:halt, cycles_list, _, _res}
        when length(cycles_list) == length(dependents) ->
          nil

        {_, cycles_list, _, _res} = input
        when length(cycles_list) == length(dependents) ->
          {input, {:halt, cycles_list}}

        {map, cycles_list, cycle_count, res} ->
          init_pulses
          |> process_signal(map, dependents)
          |> then(fn
            {{updated_map, _}, true} ->
              {{map, cycles_list, cycle_count, res},
               {updated_map,
                [cycle_count + 1 | cycles_list],
                cycle_count + 1, true}}

            {{updated_map, _}, false} ->
              {{map, cycles_list, cycle_count, res},
               {updated_map, cycles_list, cycle_count + 1,
                false}}
          end)
      end)
      |> Stream.filter(fn {_, _, _, dependent_high} ->
        dependent_high
      end)
      |> Stream.map(fn {_, cycles_list, _, _} ->
        cycles_list
      end)
      |> Enum.take(4)
      |> List.last()
      |> Enum.reduce(1, &lcm/2)
      |> IO.inspect(label: "part_2")
    end)
  end
end
```

[pulse-propagation]: https://adventofcode.com/2023/day/20
